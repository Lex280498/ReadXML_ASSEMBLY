{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LECTURA DE ARCHIVO XML ( BAJO UNA ESTRUCTURA ESPEC\u00cdFICA ) Fines Este ejemplo fue realizado \u00fanicamente con fines educativos, el c\u00f3digo utilizado queda con acceso y uso libre para que puedan basarse de la idea y mejorarla o adaptarlo a sus necesidades. Alcances El ejemplo realizado no tiene la capacidad de realizar un an\u00e1lisis de un XML gen\u00e9rico . El ejemplo solo tiene la capacidad de analizar un archivo XML, bajo una estructura espec\u00edfica que m\u00e1s adelante se describir\u00e1. Lo archivos de prueba debe de estar sin ning\u00fan tipo de error ya que no fue considerado, es decir: Toda etiqueta que fue abierta esta debe tener su respectiva etiqueta de cierre. Por lo mismo del punto anterior al encontrar una etiqueta de cierre no se verifica si es la etiqueta correspondiente a la etiqueta anteriormente abierta. Estructura del Ejemplo . `-- Read_XML/ |-- analysis/ | `-- analysis.asm |-- docs/ |-- ctrllr/ | |-- loadCtrl.asm | `-- menuCtrl.asm |-- macros/ | |-- file.asm | `-- macros.asm |-- file.xml |-- main.asm |-- MAIN.EXE `-- views/ |-- loadView.asm `-- menuView.asm Descripci\u00f3n de algunas carpetas o archivo de la estructura Archivo / Carpeta Descripci\u00f3n analysis/ en esta carpeta se encuentra la macro realizado para el an\u00e1lisis del archivo de entrada. ctrllr/ en esta carpeta se encuentra los controladores correspondiente a cada vista, son macros el cual contiene la l\u00f3gica de cada vista. macros/ en esta carpeta se encuentran las macros de prop\u00f3sito general as\u00ed como tambi\u00e9n las macros usadas para el manejo de archivos. docs/ en esta carpeta se encuentra los archivos de documentaci\u00f3n file.xml estos son los archivos de entrada para realizar analisi main.asm es el archivo principal de la practica MAIN.EXE ejecutable del ejemplo views/ en esta carpeta se encuentran las vistas de cada uno de las opciones (Men\u00fa y carga de archivo) Estructura del archivo XML El archivo contendr\u00e1 una lista de estudiantes con un los siguientes datos: Nombre que viene con espacios entre nombres y apellidos Registro o carne que tiene guiones. <STUDENT> <STUDENT1> <name> .... </name> <idCard> .... </idCard> </STUDENT1> . . . <STUDENTn> <name> .... </name> <idCard> .... </idCard> </STUDENTn> </STUDENT> Con el fin de ejemplificar se necesita que de salida muestre la siguiente etstructura: ID: [la itequeta que contiene los datos del estudiante] NOMBRE: [nombre del estudiante sin espacios] REGISTRO: [registros del estudiante sin guiones] FIN_ID Archivo de entrada de ejemplo <STUDENT> <STUDENT1> <NAME> Denis Swapan White </NAME> <idCard> 590-09-0410 </idCard> </STUDENT1> <STUDENT2> <nAmE> Moreno Goyathlay Henson </nAmE> <idcard> 214-32-0525 </idcard> </STUDENT2> <STUDENT3> <NAMe> Stela Sadia Long </NAMe> <IdCaRD> 215-69-7500 </IdCaRD> </STUDENT3> <STUDENT4> <NAMe> Wanda Barcia Brown </NAMe> <IdCaRD> 607-38-9775 </IdCaRD> </STUDENT4> </STUDENT> Salida esperada ID: student1 NOMBRE: DenisSwapanWhite REGISTRO: 590090410 FIND_ID ID: student2 NOMBRE: MorenoGoyathlayHenson REGISTRO: 214320525 FIND_ID ID: student3 NOMBRE: StelaSadiaLong REGISTRO: 215697500 FIND_ID ID: student4 NOMBRE: WandaBarciaBrown REGISTRO: 607389775 FIND_ID Salida Obtenida Capturas de Pantalla Men\u00fa Principal Carga de Archivo","title":"Inicio"},{"location":"#lectura-de-archivo-xml-bajo-una-estructura-especifica","text":"","title":"LECTURA DE ARCHIVO XML (BAJO UNA ESTRUCTURA ESPEC\u00cdFICA)"},{"location":"#fines","text":"Este ejemplo fue realizado \u00fanicamente con fines educativos, el c\u00f3digo utilizado queda con acceso y uso libre para que puedan basarse de la idea y mejorarla o adaptarlo a sus necesidades.","title":"Fines"},{"location":"#alcances","text":"El ejemplo realizado no tiene la capacidad de realizar un an\u00e1lisis de un XML gen\u00e9rico . El ejemplo solo tiene la capacidad de analizar un archivo XML, bajo una estructura espec\u00edfica que m\u00e1s adelante se describir\u00e1. Lo archivos de prueba debe de estar sin ning\u00fan tipo de error ya que no fue considerado, es decir: Toda etiqueta que fue abierta esta debe tener su respectiva etiqueta de cierre. Por lo mismo del punto anterior al encontrar una etiqueta de cierre no se verifica si es la etiqueta correspondiente a la etiqueta anteriormente abierta.","title":"Alcances"},{"location":"#estructura-del-ejemplo","text":". `-- Read_XML/ |-- analysis/ | `-- analysis.asm |-- docs/ |-- ctrllr/ | |-- loadCtrl.asm | `-- menuCtrl.asm |-- macros/ | |-- file.asm | `-- macros.asm |-- file.xml |-- main.asm |-- MAIN.EXE `-- views/ |-- loadView.asm `-- menuView.asm","title":"Estructura del Ejemplo"},{"location":"#descripcion-de-algunas-carpetas-o-archivo-de-la-estructura","text":"Archivo / Carpeta Descripci\u00f3n analysis/ en esta carpeta se encuentra la macro realizado para el an\u00e1lisis del archivo de entrada. ctrllr/ en esta carpeta se encuentra los controladores correspondiente a cada vista, son macros el cual contiene la l\u00f3gica de cada vista. macros/ en esta carpeta se encuentran las macros de prop\u00f3sito general as\u00ed como tambi\u00e9n las macros usadas para el manejo de archivos. docs/ en esta carpeta se encuentra los archivos de documentaci\u00f3n file.xml estos son los archivos de entrada para realizar analisi main.asm es el archivo principal de la practica MAIN.EXE ejecutable del ejemplo views/ en esta carpeta se encuentran las vistas de cada uno de las opciones (Men\u00fa y carga de archivo)","title":"Descripci\u00f3n de algunas carpetas o archivo de la estructura"},{"location":"#estructura-del-archivo-xml","text":"El archivo contendr\u00e1 una lista de estudiantes con un los siguientes datos: Nombre que viene con espacios entre nombres y apellidos Registro o carne que tiene guiones. <STUDENT> <STUDENT1> <name> .... </name> <idCard> .... </idCard> </STUDENT1> . . . <STUDENTn> <name> .... </name> <idCard> .... </idCard> </STUDENTn> </STUDENT> Con el fin de ejemplificar se necesita que de salida muestre la siguiente etstructura: ID: [la itequeta que contiene los datos del estudiante] NOMBRE: [nombre del estudiante sin espacios] REGISTRO: [registros del estudiante sin guiones] FIN_ID","title":"Estructura del archivo XML"},{"location":"#archivo-de-entrada-de-ejemplo","text":"<STUDENT> <STUDENT1> <NAME> Denis Swapan White </NAME> <idCard> 590-09-0410 </idCard> </STUDENT1> <STUDENT2> <nAmE> Moreno Goyathlay Henson </nAmE> <idcard> 214-32-0525 </idcard> </STUDENT2> <STUDENT3> <NAMe> Stela Sadia Long </NAMe> <IdCaRD> 215-69-7500 </IdCaRD> </STUDENT3> <STUDENT4> <NAMe> Wanda Barcia Brown </NAMe> <IdCaRD> 607-38-9775 </IdCaRD> </STUDENT4> </STUDENT>","title":"Archivo de entrada de ejemplo"},{"location":"#salida-esperada","text":"ID: student1 NOMBRE: DenisSwapanWhite REGISTRO: 590090410 FIND_ID ID: student2 NOMBRE: MorenoGoyathlayHenson REGISTRO: 214320525 FIND_ID ID: student3 NOMBRE: StelaSadiaLong REGISTRO: 215697500 FIND_ID ID: student4 NOMBRE: WandaBarciaBrown REGISTRO: 607389775 FIND_ID","title":"Salida esperada"},{"location":"#salida-obtenida","text":"","title":"Salida Obtenida"},{"location":"#capturas-de-pantalla","text":"","title":"Capturas de Pantalla"},{"location":"#menu-principal","text":"","title":"Men\u00fa Principal"},{"location":"#carga-de-archivo","text":"","title":"Carga de Archivo"},{"location":"about/","text":"About UNIVERSIDAD DE SAN CARLOS DE GUATEMALA Facultad de Ingenier\u00eda Escuela en Ciencias y Sistema Nombre: Alex Fernando M\u00e9ndez L\u00f3pez Correo de Contacto: afml183@gmail.com Referencias Libros (Brey, 2006),(Brey, 2006, Chapter 5),(Brey, 2006, Chapter 6) Brey, B. B. (2006). Microprocesadores Intel - 7 Edicion . Pearson Publications Company. (Irvine, 2014),(Irvine, 2014, Chapter 6),(Irvine, 2014, Chapter 9) Irvine, K. R. (2014). Assembly language for x86 processors (7th ed.). Upper Saddle River, NJ: Pearson. Sitios Web Interrupci\u00f3n 21h Interrupci\u00f3n 10h Gu\u00eda de Ensamblador - NASM Curso B\u00e1sico de Ensamblador Intel 80x86","title":"Acerda De y Referencias"},{"location":"about/#about","text":"UNIVERSIDAD DE SAN CARLOS DE GUATEMALA Facultad de Ingenier\u00eda Escuela en Ciencias y Sistema Nombre: Alex Fernando M\u00e9ndez L\u00f3pez Correo de Contacto: afml183@gmail.com","title":"About"},{"location":"about/#referencias","text":"","title":"Referencias"},{"location":"about/#libros","text":"(Brey, 2006),(Brey, 2006, Chapter 5),(Brey, 2006, Chapter 6) Brey, B. B. (2006). Microprocesadores Intel - 7 Edicion . Pearson Publications Company. (Irvine, 2014),(Irvine, 2014, Chapter 6),(Irvine, 2014, Chapter 9) Irvine, K. R. (2014). Assembly language for x86 processors (7th ed.). Upper Saddle River, NJ: Pearson.","title":"Libros"},{"location":"about/#sitios-web","text":"Interrupci\u00f3n 21h Interrupci\u00f3n 10h Gu\u00eda de Ensamblador - NASM Curso B\u00e1sico de Ensamblador Intel 80x86","title":"Sitios Web"},{"location":"analysis/","text":"AN\u00c1LISIS Y CARGA DEL ARCHIVO XML Descripci\u00f3n En este apartado se encuentran el c\u00f3digo utilizado para realizar la lectura y an\u00e1lisis del archivo de entrada en formato XML, anteriormente ya se menciono el alcance y la estructura que debe de llevar el archivo de entrada. Grafo De estados Descripci\u00f3n de los estados Estado Descripci\u00f3n S0 estado inicial, el cual ignorar\u00e1 la primera linea S1 estado donde verifica si es una etiqueta que se este abriendo o es una etiqueta de cierre LIMPIAR DI estado donde se limpiara el registro DI ETIQUETA estado donde se almacena dentro de un buffer todos los caracteres de la etiqueta hasta que encuentre el s\u00edmbolo de cierre ( > ) PALABRA CLAVE estado donde verifica si el id almacenado en el estado anterior es una de las palabras claves o reservadas, se tomaron como palabras claves los siguientes id's: - NAME - IDCARD ACCION1 estado donde almacena el nombre del estudiante omitiendo los espacios ACCION2 estado donde almacena el idCard o carnet del estudiante omitiendo los guiones que este pueda tener LIMPIAR DI 1 estado donde se limpiara el registro DI ETIQUETA DE CIERRE estado donde se almacena dentro de un buffer todos los caracteres hasta que encuentre el s\u00edmbolo de > VERIFICAR ID estado donde se verifica si la etiqueta de cierre corresponde de a la etiqueta <STUDENTn> (donde n es el n\u00famero de estudiante) para poder mostrar el resultado de las acciones realizadas. ACCION3 estado donde se muestra el resultado de las dos acciones anteriores y se limpian los buffer's. FIN estado final, al encontrar el s\u00edmbolo de fin de archivo < > ( $ ) C\u00f3digo Par\u00e1metros Par\u00e1metro Descripaci\u00f3n buffer buffer que almacena el contenido del archivo anteriormente le\u00eddo. Macro analisis MACRO buffer .data ;; ///////// palabras claves o reservadas //////////////////////////////////// pcNombre DB \"name$\" pcRegistro DB \"idcard$\" ;; ///////// Buffer's //////////////////////////////////// bufferRespaldoId DB 100 DUP ( '$' ), '$' bufferString DB 100 DUP ( '$' ), '$' bufferNombre DB 100 DUP ( '$' ), '$' bufferRegistro DB 100 DUP ( '$' ), '$' ;; ///////// mensajes //////////////////////////////////// msgId DB 0Ah , \"ID: $\" msgEndId DB 0Ah , \"FIN_ID\" , 0Ah , \"$\" msgNombre DB 0Ah , 09h , \"NOMBRE: $\" msgRegistro DB 0Ah , 09h , \"REGISTRO: $\" .code CALL limpiarRegistros MOV si , - 1 S0: CALL si guienteCaracter CMP bl , 10 ;; if bl = '\\n' (salto de linea) JE S1 CMP bl , 13 ;; if bl = '\\r' (regreso de carro) JE S1 CMP bl , 36 ;; if bl == '$' (FIN_ANALISIS de archivo->EOF) JE FIN_ANALISIS JMP S0 S1: CALL si guienteCaracter CMP bl , 36 ;; if bl == '$' (FIN_ANALISIS de archivo->EOF) JE FIN_ANALISIS CMP bl , 47 ;; if bl == '/' JE LIMPIAR_DI_1 CMP bl , 60 ;; if bl == '<' JE LIMPIAR_DI JMP S1 LIMPIAR_DI: limpiarBuffer bufferString XOR di , di ETIQUETA: CALL si guienteCaracter CMP bl , 47 ;; if bl == '/' JE LIMPIAR_DI_1 CMP bl , 62 ;; if bl == '>' JE PALABRA_CLAVE MOV bufferString [ di ], bl INC di JMP ETIQUETA PALABRA_CLAVE: CALL respaldo compararIngorandoCase pcNombre , bufferString ;; kwAdd.equalIgnoreCase(buffer) JE ACCION_1 compararIngorandoCase pcRegistro , bufferString ;; kwAdd.equalIgnoreCase(buffer) JE ACCION_2 copyData bufferRespaldoId , bufferString CALL restaurar JMP S1 ACCION_1: CALL restaurar CALL leerNombre JMP S1 ACCION_2: CALL restaurar CALL leerCarnet JMP S1 LIMPIAR_DI_1: limpiarBuffer bufferString XOR di , di ETIQUETA_DE_CIERRE: CALL si guienteCaracter CMP bl , 62 ;; if bl == '>' JE VERIFICAR_ID MOV bufferString [ di ], bl INC di JMP ETIQUETA_DE_CIERRE VERIFICAR_ID: CALL respaldo compararIngorandoCase bufferRespaldoId , bufferString JE ACCION_3 CALL restaurar JMP S1 ACCION_3: imprimir msgId imprimir bufferRespaldoId imprimir msgNombre imprimir bufferNombre imprimir msgRegistro imprimir bufferRegistro imprimir msgEndId limpiarBuffer bufferRespaldoId limpiarBuffer bufferNombre limpiarBuffer bufferRegistro CALL restaurar JMP S1 leerNombre PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 32 ;; if bl == ' ' JE L1 MOV bufferNombre [ di ], bl INC di JMP L1 L2: ret leerNombre ENDP leerCarnet PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 45 ;; if bl == '-' JE L1 MOV bufferRegistro [ di ], bl INC di JMP L1 L2: ret leerCarnet ENDP siguienteCaracter PROC INC si MOV bl , buffer [ si ] ret siguienteCaracter ENDP FIN_ANALISIS: ENDM","title":"Anal\u00edsis"},{"location":"analysis/#analisis-y-carga-del-archivo-xml","text":"","title":"AN\u00c1LISIS Y CARGA DEL ARCHIVO XML"},{"location":"analysis/#descripcion","text":"En este apartado se encuentran el c\u00f3digo utilizado para realizar la lectura y an\u00e1lisis del archivo de entrada en formato XML, anteriormente ya se menciono el alcance y la estructura que debe de llevar el archivo de entrada.","title":"Descripci\u00f3n"},{"location":"analysis/#grafo-de-estados","text":"","title":"Grafo De estados"},{"location":"analysis/#descripcion-de-los-estados","text":"Estado Descripci\u00f3n S0 estado inicial, el cual ignorar\u00e1 la primera linea S1 estado donde verifica si es una etiqueta que se este abriendo o es una etiqueta de cierre LIMPIAR DI estado donde se limpiara el registro DI ETIQUETA estado donde se almacena dentro de un buffer todos los caracteres de la etiqueta hasta que encuentre el s\u00edmbolo de cierre ( > ) PALABRA CLAVE estado donde verifica si el id almacenado en el estado anterior es una de las palabras claves o reservadas, se tomaron como palabras claves los siguientes id's: - NAME - IDCARD ACCION1 estado donde almacena el nombre del estudiante omitiendo los espacios ACCION2 estado donde almacena el idCard o carnet del estudiante omitiendo los guiones que este pueda tener LIMPIAR DI 1 estado donde se limpiara el registro DI ETIQUETA DE CIERRE estado donde se almacena dentro de un buffer todos los caracteres hasta que encuentre el s\u00edmbolo de > VERIFICAR ID estado donde se verifica si la etiqueta de cierre corresponde de a la etiqueta <STUDENTn> (donde n es el n\u00famero de estudiante) para poder mostrar el resultado de las acciones realizadas. ACCION3 estado donde se muestra el resultado de las dos acciones anteriores y se limpian los buffer's. FIN estado final, al encontrar el s\u00edmbolo de fin de archivo < > ( $ )","title":"Descripci\u00f3n de los estados"},{"location":"analysis/#codigo","text":"","title":"C\u00f3digo"},{"location":"analysis/#parametros","text":"Par\u00e1metro Descripaci\u00f3n buffer buffer que almacena el contenido del archivo anteriormente le\u00eddo.","title":"Par\u00e1metros"},{"location":"analysis/#macro","text":"analisis MACRO buffer .data ;; ///////// palabras claves o reservadas //////////////////////////////////// pcNombre DB \"name$\" pcRegistro DB \"idcard$\" ;; ///////// Buffer's //////////////////////////////////// bufferRespaldoId DB 100 DUP ( '$' ), '$' bufferString DB 100 DUP ( '$' ), '$' bufferNombre DB 100 DUP ( '$' ), '$' bufferRegistro DB 100 DUP ( '$' ), '$' ;; ///////// mensajes //////////////////////////////////// msgId DB 0Ah , \"ID: $\" msgEndId DB 0Ah , \"FIN_ID\" , 0Ah , \"$\" msgNombre DB 0Ah , 09h , \"NOMBRE: $\" msgRegistro DB 0Ah , 09h , \"REGISTRO: $\" .code CALL limpiarRegistros MOV si , - 1 S0: CALL si guienteCaracter CMP bl , 10 ;; if bl = '\\n' (salto de linea) JE S1 CMP bl , 13 ;; if bl = '\\r' (regreso de carro) JE S1 CMP bl , 36 ;; if bl == '$' (FIN_ANALISIS de archivo->EOF) JE FIN_ANALISIS JMP S0 S1: CALL si guienteCaracter CMP bl , 36 ;; if bl == '$' (FIN_ANALISIS de archivo->EOF) JE FIN_ANALISIS CMP bl , 47 ;; if bl == '/' JE LIMPIAR_DI_1 CMP bl , 60 ;; if bl == '<' JE LIMPIAR_DI JMP S1 LIMPIAR_DI: limpiarBuffer bufferString XOR di , di ETIQUETA: CALL si guienteCaracter CMP bl , 47 ;; if bl == '/' JE LIMPIAR_DI_1 CMP bl , 62 ;; if bl == '>' JE PALABRA_CLAVE MOV bufferString [ di ], bl INC di JMP ETIQUETA PALABRA_CLAVE: CALL respaldo compararIngorandoCase pcNombre , bufferString ;; kwAdd.equalIgnoreCase(buffer) JE ACCION_1 compararIngorandoCase pcRegistro , bufferString ;; kwAdd.equalIgnoreCase(buffer) JE ACCION_2 copyData bufferRespaldoId , bufferString CALL restaurar JMP S1 ACCION_1: CALL restaurar CALL leerNombre JMP S1 ACCION_2: CALL restaurar CALL leerCarnet JMP S1 LIMPIAR_DI_1: limpiarBuffer bufferString XOR di , di ETIQUETA_DE_CIERRE: CALL si guienteCaracter CMP bl , 62 ;; if bl == '>' JE VERIFICAR_ID MOV bufferString [ di ], bl INC di JMP ETIQUETA_DE_CIERRE VERIFICAR_ID: CALL respaldo compararIngorandoCase bufferRespaldoId , bufferString JE ACCION_3 CALL restaurar JMP S1 ACCION_3: imprimir msgId imprimir bufferRespaldoId imprimir msgNombre imprimir bufferNombre imprimir msgRegistro imprimir bufferRegistro imprimir msgEndId limpiarBuffer bufferRespaldoId limpiarBuffer bufferNombre limpiarBuffer bufferRegistro CALL restaurar JMP S1 leerNombre PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 32 ;; if bl == ' ' JE L1 MOV bufferNombre [ di ], bl INC di JMP L1 L2: ret leerNombre ENDP leerCarnet PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 45 ;; if bl == '-' JE L1 MOV bufferRegistro [ di ], bl INC di JMP L1 L2: ret leerCarnet ENDP siguienteCaracter PROC INC si MOV bl , buffer [ si ] ret siguienteCaracter ENDP FIN_ANALISIS: ENDM","title":"Macro"},{"location":"proc/","text":"PROCEDIMIENTOS Descripci\u00f3n En este apartado se encuentran los procedimientos usados para el desarrollo del ejemplo. Procedimientos declarados en archivo main.asm Main Proc main PROC MOV dx , @ data MOV ds , dx MOV es , dx MAIN_MENU: mainMenuView LOAD_FILE: fileLoadView EXIT: MOV ah , 4ch INT 21h main ENDP Prop\u00f3sito main: procedimiento principal, el cual es llamado al ejecutarse el programa. Limpiar Registros Proc limpiarRegistros PROC XOR ax , ax XOR bx , bx XOR cx , cx XOR dx , dx XOR si , si XOR di , di ret limpiarRegistros ENDP Prop\u00f3sito limpiarRegistros: procedimiento para limpiar los registros mas usados. Respaldar la informaci\u00f3n de los registros Proc .data axBk DW ? bxBK DW ? cxBK DW ? dxBk DW ? siBk DW ? diBk DW ? .code respaldo PROC MOV ax Bk , ax MOV bx Bk , bx MOV cx Bk , cx MOV dx Bk , dx MOV si Bk , si MOV di Bk , di ret respaldo ENDP Prop\u00f3sito respaldo: procedimiento para respaldar el contenido de los registros en memoria, esto debido a que algunas macros hacen una limpieza de algunos de ellos, por lo tanto, antes de de ser llamados es necesario hacer un respaldo y no perder la informaci\u00f3n. Este procedimiento se usa mas durante el an\u00e1lisis. Restaurar la informaci\u00f3n de los registros Proc .data axBk DW ? bxBK DW ? cxBK DW ? dxBk DW ? siBk DW ? diBk DW ? .code rest aurar PROC MOV ax , ax Bk MOV bx , bx Bk MOV cx , cx Bk MOV dx , dx Bk MOV si , si Bk MOV di , di Bk ret rest aurar ENDP Prop\u00f3sito restaurar: procedimiento para restaurar el contenido de los registros que se encuentra en memoria. Este procedimiento se usa mas durante el an\u00e1lisis. Procedimientos declarados en archivo analysis.asm Leer Nombre Proc leerNombre PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 32 ;; if bl == ' ' JE L1 MOV bufferNombre [ di ], bl INC di JMP L1 L2: ret leerNombre ENDP Prop\u00f3sito leerNombre: procedimiento para almacenar el nombre ignorado los espacios, luego de encontrar la etiqueta <name> durante la lectura y an\u00e1lisis del archivo xml. Leer Carnet Proc leerCarnet PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 45 ;; if bl == '-' JE L1 MOV bufferRegistro [ di ], bl INC di JMP L1 L2: ret leerCarnet ENDP Prop\u00f3sito leerCarnet: procedimiento para almacenar el carnet en el ignorado los guiones (-), luego de encontrar la etiqueta <idcard> durante la lectura y an\u00e1lisis del archivo xml. Obtener siguiente Car\u00e1cter Proc siguienteCaracter PROC INC si MOV bl , buffer [ si ] ret siguienteCaracter ENDP Prop\u00f3sito siguienteCaracter: procedimiento para obtener el siguiente car\u00e1cter, del buffer que contiene todo el contenido del archivo durante el an\u00e1lisis del archivo","title":"Procedimientos"},{"location":"proc/#procedimientos","text":"","title":"PROCEDIMIENTOS"},{"location":"proc/#descripcion","text":"En este apartado se encuentran los procedimientos usados para el desarrollo del ejemplo.","title":"Descripci\u00f3n"},{"location":"proc/#procedimientos-declarados-en-archivo-mainasm","text":"","title":"Procedimientos declarados en archivo main.asm"},{"location":"proc/#main","text":"","title":"Main"},{"location":"proc/#proc","text":"main PROC MOV dx , @ data MOV ds , dx MOV es , dx MAIN_MENU: mainMenuView LOAD_FILE: fileLoadView EXIT: MOV ah , 4ch INT 21h main ENDP","title":"Proc"},{"location":"proc/#proposito","text":"main: procedimiento principal, el cual es llamado al ejecutarse el programa.","title":"Prop\u00f3sito"},{"location":"proc/#limpiar-registros","text":"","title":"Limpiar Registros"},{"location":"proc/#proc_1","text":"limpiarRegistros PROC XOR ax , ax XOR bx , bx XOR cx , cx XOR dx , dx XOR si , si XOR di , di ret limpiarRegistros ENDP","title":"Proc"},{"location":"proc/#proposito_1","text":"limpiarRegistros: procedimiento para limpiar los registros mas usados.","title":"Prop\u00f3sito"},{"location":"proc/#respaldar-la-informacion-de-los-registros","text":"","title":"Respaldar la informaci\u00f3n de los registros"},{"location":"proc/#proc_2","text":".data axBk DW ? bxBK DW ? cxBK DW ? dxBk DW ? siBk DW ? diBk DW ? .code respaldo PROC MOV ax Bk , ax MOV bx Bk , bx MOV cx Bk , cx MOV dx Bk , dx MOV si Bk , si MOV di Bk , di ret respaldo ENDP","title":"Proc"},{"location":"proc/#proposito_2","text":"respaldo: procedimiento para respaldar el contenido de los registros en memoria, esto debido a que algunas macros hacen una limpieza de algunos de ellos, por lo tanto, antes de de ser llamados es necesario hacer un respaldo y no perder la informaci\u00f3n. Este procedimiento se usa mas durante el an\u00e1lisis.","title":"Prop\u00f3sito"},{"location":"proc/#restaurar-la-informacion-de-los-registros","text":"","title":"Restaurar la informaci\u00f3n de los registros"},{"location":"proc/#proc_3","text":".data axBk DW ? bxBK DW ? cxBK DW ? dxBk DW ? siBk DW ? diBk DW ? .code rest aurar PROC MOV ax , ax Bk MOV bx , bx Bk MOV cx , cx Bk MOV dx , dx Bk MOV si , si Bk MOV di , di Bk ret rest aurar ENDP","title":"Proc"},{"location":"proc/#proposito_3","text":"restaurar: procedimiento para restaurar el contenido de los registros que se encuentra en memoria. Este procedimiento se usa mas durante el an\u00e1lisis.","title":"Prop\u00f3sito"},{"location":"proc/#procedimientos-declarados-en-archivo-analysisasm","text":"","title":"Procedimientos declarados en archivo analysis.asm"},{"location":"proc/#leer-nombre","text":"","title":"Leer Nombre"},{"location":"proc/#proc_4","text":"leerNombre PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 32 ;; if bl == ' ' JE L1 MOV bufferNombre [ di ], bl INC di JMP L1 L2: ret leerNombre ENDP","title":"Proc"},{"location":"proc/#proposito_4","text":"leerNombre: procedimiento para almacenar el nombre ignorado los espacios, luego de encontrar la etiqueta <name> durante la lectura y an\u00e1lisis del archivo xml.","title":"Prop\u00f3sito"},{"location":"proc/#leer-carnet","text":"","title":"Leer Carnet"},{"location":"proc/#proc_5","text":"leerCarnet PROC XOR di , di L1: CALL si guienteCaracter CMP bl , 60 ;; if bl == '<' JE L2 CMP bl , 45 ;; if bl == '-' JE L1 MOV bufferRegistro [ di ], bl INC di JMP L1 L2: ret leerCarnet ENDP","title":"Proc"},{"location":"proc/#proposito_5","text":"leerCarnet: procedimiento para almacenar el carnet en el ignorado los guiones (-), luego de encontrar la etiqueta <idcard> durante la lectura y an\u00e1lisis del archivo xml.","title":"Prop\u00f3sito"},{"location":"proc/#obtener-siguiente-caracter","text":"","title":"Obtener siguiente Car\u00e1cter"},{"location":"proc/#proc_6","text":"siguienteCaracter PROC INC si MOV bl , buffer [ si ] ret siguienteCaracter ENDP","title":"Proc"},{"location":"proc/#proposito_6","text":"siguienteCaracter: procedimiento para obtener el siguiente car\u00e1cter, del buffer que contiene todo el contenido del archivo durante el an\u00e1lisis del archivo","title":"Prop\u00f3sito"},{"location":"macros/files/","text":"MANEJO DE ARCHIVOS Descripci\u00f3n En este apartado se encuentra la macros utilizadas para el manejo de archivos, para la implementaci\u00f3n de estas macros se utiliz\u00f3 la interrupci\u00f3n (INT) 21h Abrir un Archivo Macro abrirArchivo MACRO path , handle LOCAL ERROR , FIN MOV ah , 3dh MOV al , 10b LEA dx , path INT 21h MOV handle , ax JC ERROR JNC FIN ERROR: imprimir errorOpenFile JMP MAIN_MENU FIN: ENDM Prop\u00f3sito abrirArchivo: Mediante esta macro se abre un fichero ya existente, y se almacena un manejador del archivo para poder escribir o leer el fichero posteriormenten. Par\u00e1metros Par\u00e1metro Descripci\u00f3n path ruta donde se encuentra el archivo a abrir. handle variable donde se almacenara el manejador de 16bits para accerder posteriormente al archivo. Cerrar un Archivo Macro cerrarArchivo MACRO handle LOCAL ERROR , FIN MOV ah , 3eh MOV handle , bx INT 21h JC ERROR JNC FIN ERROR: imprimir errorCloseFile JMP MAIN_MENU FIN: ENDM Prop\u00f3sito cerrarArchivo: Mediante esta macro se cierra un fichero que estuviera abierto. Se utiliza el Handle para indicar el fichero a cerrar. Tras cerrar el fichero, dicho Handle se libera para nuevos ficheros. Par\u00e1metros Par\u00e1metro Descripci\u00f3n handle manejador de archivo de 16bits. Lectura de un Archivo Macro leerArchivo MACRO buffer , si ze , handle LOCAL ERROR , FIN MOV ah , 3fh MOV bx , handle MOV cx , si ze LEA dx , buffer INT 21h JC ERROR JNC FIN ERROR: imprimir errorReadFile JMP MAIN_MENU FIN: ENDM Prop\u00f3sito leerArchivo: Dado un handle v\u00e1lido, se realiza una transferencia desde el fichero referenciado por el handle hacia el buffer de memoria especificado mediante DS:DX. Se transferir\u00e1n tantos caracteres como se especifique en CX. Acto seguido, se actualiza el puntero de fichero hasta el car\u00e1cter que sigue al bloque le\u00eddo. Mediante esta funci\u00f3n es posible leer caracteres del teclado, usando el handle 0. Par\u00e1metros Par\u00e1metro Descripci\u00f3n buffer buffer donde se almacenar\u00e1 el contenido del fichero size cantidad de caracteres que se transferir\u00e1n del archivo al buffer handle manejador del archivo del cual se leer\u00e1","title":"Manejo de Archivos"},{"location":"macros/files/#manejo-de-archivos","text":"","title":"MANEJO DE ARCHIVOS"},{"location":"macros/files/#descripcion","text":"En este apartado se encuentra la macros utilizadas para el manejo de archivos, para la implementaci\u00f3n de estas macros se utiliz\u00f3 la interrupci\u00f3n (INT) 21h","title":"Descripci\u00f3n"},{"location":"macros/files/#abrir-un-archivo","text":"","title":"Abrir un Archivo"},{"location":"macros/files/#macro","text":"abrirArchivo MACRO path , handle LOCAL ERROR , FIN MOV ah , 3dh MOV al , 10b LEA dx , path INT 21h MOV handle , ax JC ERROR JNC FIN ERROR: imprimir errorOpenFile JMP MAIN_MENU FIN: ENDM","title":"Macro"},{"location":"macros/files/#proposito","text":"abrirArchivo: Mediante esta macro se abre un fichero ya existente, y se almacena un manejador del archivo para poder escribir o leer el fichero posteriormenten.","title":"Prop\u00f3sito"},{"location":"macros/files/#parametros","text":"Par\u00e1metro Descripci\u00f3n path ruta donde se encuentra el archivo a abrir. handle variable donde se almacenara el manejador de 16bits para accerder posteriormente al archivo.","title":"Par\u00e1metros"},{"location":"macros/files/#cerrar-un-archivo","text":"","title":"Cerrar un Archivo"},{"location":"macros/files/#macro_1","text":"cerrarArchivo MACRO handle LOCAL ERROR , FIN MOV ah , 3eh MOV handle , bx INT 21h JC ERROR JNC FIN ERROR: imprimir errorCloseFile JMP MAIN_MENU FIN: ENDM","title":"Macro"},{"location":"macros/files/#proposito_1","text":"cerrarArchivo: Mediante esta macro se cierra un fichero que estuviera abierto. Se utiliza el Handle para indicar el fichero a cerrar. Tras cerrar el fichero, dicho Handle se libera para nuevos ficheros.","title":"Prop\u00f3sito"},{"location":"macros/files/#parametros_1","text":"Par\u00e1metro Descripci\u00f3n handle manejador de archivo de 16bits.","title":"Par\u00e1metros"},{"location":"macros/files/#lectura-de-un-archivo","text":"","title":"Lectura de un Archivo"},{"location":"macros/files/#macro_2","text":"leerArchivo MACRO buffer , si ze , handle LOCAL ERROR , FIN MOV ah , 3fh MOV bx , handle MOV cx , si ze LEA dx , buffer INT 21h JC ERROR JNC FIN ERROR: imprimir errorReadFile JMP MAIN_MENU FIN: ENDM","title":"Macro"},{"location":"macros/files/#proposito_2","text":"leerArchivo: Dado un handle v\u00e1lido, se realiza una transferencia desde el fichero referenciado por el handle hacia el buffer de memoria especificado mediante DS:DX. Se transferir\u00e1n tantos caracteres como se especifique en CX. Acto seguido, se actualiza el puntero de fichero hasta el car\u00e1cter que sigue al bloque le\u00eddo. Mediante esta funci\u00f3n es posible leer caracteres del teclado, usando el handle 0.","title":"Prop\u00f3sito"},{"location":"macros/files/#parametros_2","text":"Par\u00e1metro Descripci\u00f3n buffer buffer donde se almacenar\u00e1 el contenido del fichero size cantidad de caracteres que se transferir\u00e1n del archivo al buffer handle manejador del archivo del cual se leer\u00e1","title":"Par\u00e1metros"},{"location":"macros/macros/","text":"MACROS DE PROP\u00d3SITO GENERAL Descripci\u00f3n En este apartado se encuentran varios macros de prop\u00f3sito general que son utilizada para completar la l\u00f3gica del ejemplo, poder interactuar con el usuario y macros usados durante durante el an\u00e1lisis. Algunas de las macros descrita en este apartado fueron implementados usando la interrupci\u00f3n (INT) 21h IMPORTANTE En varias de siguientes macros se usaran instrucciones primitivas que nos permite manejar o procesar de forma f\u00e1cil grandes bloques de datos, por lo cual es de suma importancia el uso del segmento EXTRA DATA (es) , si revisamos el main al incio de la proc main hay una l\u00ednea de c\u00f3digo en la cual hacemos uso del segmento extra data. main PROC MOV dx , @ data MOV ds , dx ;; uso del segmento de datos (DS) MOV es , dx ;; uso del segmento extra dato (es) ;; ... ;; ... ;; .. m\u00e1s c\u00f3digo main ENDP Visualizaci\u00f3n de un car\u00e1cter en pantalla Macro imprimirC MACRO ch aracter MOV ah , 02h MOV dl , ch aracter INT 21h ENDM Prop\u00f3sito imprimirC: macro para imprimir o visualizar una car\u00e1cter en pantalla, el car\u00e1cter debe de estar en su valor ascii. Par\u00e1metros Par\u00e1metro Descripci\u00f3n character car\u00e1cter a visualizar en pantalla Retorno nada Visualizaci\u00f3n de una cadena de caracteres en pantalla Macro imprimir MACRO string MOV ah , 09h MOV dx , offset string INT 21h ENDM Prop\u00f3sito imprimir: macro para imprimir o visualizar una cadena de caracteres en pantalla, los caracteres deben estar en su valor ascii. Par\u00e1metros Par\u00e1metro Descripci\u00f3n string buffer que contiene el conjunto de caracteres a visualizar en pantalla Retorno nada Entrada o lectura de car\u00e1cter Macro leerCaracter MACRO MOV ah , 01h ;; con ECHO ; MOV ah, 08h ;; sin ECHO INT 21h ENDM Prop\u00f3sito leerCaracter: macro para leer un car\u00e1cter del dispositivo de entrada, este puede tener dos variantes. Con Echo: Mov ah, 01h , el car\u00e1cter de entrada se muestra en pantalla o el dispositivo de salida. Sin Echo: Mov ah, 08h , el car\u00e1cter de entrada no se muestra en pantalla o el dispositivo de salida. Par\u00e1metros Retorno AL = 'c\u00f3digo ascii del car\u00e1cter le\u00eddo' Entrada o lectura de una cadena de caracteres Macro leerCadena MACRO buffer LOCAL LEER , FIN XOR si , si LEER: leerCaracter CMP al , 13 ; 0ah->\\n (LINE FEED) 0dh-> retorno de carro JE FIN MOV buffer [ si ], al INC si JMP LEER FIN: MOV buffer [ si ], 00h ENDM Prop\u00f3sito leerCadena: macro para leer una cadena de caracteres del dispositivo de entrada. Par\u00e1metros Par\u00e1metro Descripci\u00f3n buffer buffer el cual servir\u00e1 para almacenar la cadena de caracteres le\u00eddos. Retorno nada Limpiar pantalla o consola Macro limpiarConsola MACRO MOV AX , 0600H ;Llamada a la funci\u00f3n MOV BH , 07H ;color de fondo y color de letra MOV CX , 0000H ;coordenadas de inicio MOV DX , 184FH ;coordenadas de fin INT 10H ENDM limpiarConsola MACRO LOCAL CL EAR MOV cx , 15 CLEAR: printChar 0Ah LOOP CL EAR ENDM Prop\u00f3sito clearConsole: macro para limpiar la consola, para este hay dos soluciones: La primera es usando la interrupci\u00f3n 10h. La segunda es hacer un LOOP imprimiendo saltos de linea. Par\u00e1metros Retorno nada Convertir una cadena de texto a min\u00fasculas Nota Ya que estamos trabajando con los valores ascii de los caracteres es muy sencillo convertir las letras en may\u00fasculas o min\u00fasculas, basta con observar una tabla de los valores ascii, tomemos por ejemplo las siguientes letras Valor Ascii (decimal) Letra May\u00fascula Valor Ascii (decimal) Letra Min\u00fascula 65 A 97 a 66 B 98 b 67 C 99 c . . . . . . . . . . . . 88 X 120 x 89 Y 121 y 90 Z 122 z En conclusi\u00f3n: El rango de las letras may\u00fasculas esta entre [65, 90]. El rango de las letras min\u00fasculas esta entre [97, 122] Para pasar de May\u00fascula a Min\u00fascula basta con sumar 32(d) al valor ascii del car\u00e1cter. Para pasar de Min\u00fascula a May\u00fascula basta con restar 32(d) al valor ascii del car\u00e1cter. Macro toLowerCase MACRO string LOCAL ITERATE , NEXT , END_TO_LOWERCASE XOR si , si MOV cx , LENGTHOF string ITERATE: CMP string [ si ], 36 JE END_TO_LOWERCASE ;; jump if string[si] == '$' CMP string [ si ], 65 JB NEXT ;; jump if string[si] < 65d CMP string [ si ], 90 JA NEXT ;; jump if string[si] > 90d ADD string [ si ], 32 INC si LOOP ITERATE JMP END_TO_LOWERCASE NEXT: INC si JMP ITERATE END_TO_LOWERCASE: ENDM Prop\u00f3sito toLowerCase: macro que convierte una cadena de letras a min\u00fasculas, modificando la misma cadena o buffer que es pasado. Par\u00e1metros Par\u00e1metro Descripci\u00f3n string cadena de texto o buffer para convertir a min\u00fasculas Retorno nada Comparar dos cadenas de caracteres o buffer's Algo de teor\u00eda Para poder manipular bloques de datos hay instrucciones primitivas que nos permite manejar o procesar de forma f\u00e1cil arrays de bytes , words y double words . COMPARE (CMPSB, CMPSW, CMPSD) Esta instrucci\u00f3n primitiva nos ayuda a comparar el contenido de de dos posiciones de memoria direccionadas o indexadas por los registros SI (8 y 16 bits) o ESI (32 bits) y DI (8 y 16 bits) o EDI (32 bits). INSTRUCCI\u00d3N DESCRIPCI\u00d3N CMPSB comparar bytes CMPSW comparar words CMPSD comparar double words Ambos registros, SI o ESI y DI o EDI , se incrementan de forma autom\u00e1tica. En esta macro aparece el nen\u00f3mico REP de repetici\u00f3n. El prefijo de repetici\u00f3n le permite procesar un array completa usando una sola instrucci\u00f3n. Se pueden utilizar los siguientes prefijos de repetici\u00f3n: INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 repetir mientras ECX > 0 REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis) Macro compararCadenas MACRO string , string2 LEA si , string LEA di , string2 MOV cx , LENGTHOF string REPE CMPSB ENDM Prop\u00f3sito compareString: comparar el contenido entre dos cadenas o buffer's, la comparaci\u00f3n lo realiza a trav\u00e9s del valor ascii de cada car\u00e1cter, tener en cuenta que la comparaci\u00f3n es debe ser de dos arrays de tipo byte. Par\u00e1metros Par\u00e1metro Descripci\u00f3n string primera cadena o buffer a comparar string2 segunda cadena o buffer a comparar Retorno Si las cadenas son iguales ZF ( zero flag ) = 1 Si las cadenas No son iguales ZF ( zero flag ) = 0 Comparar dos cadenas de caracteres o buffer's case-insensitive Macro compararIngorandoCase MACRO string , string2 toLowerCase string toLowerCase string2 compareString string , string2 ENDM Prop\u00f3sito compararIngorandoCase: comparar el contenido entre dos cadenas o buffer's de forma case-insensitive, para lograrlo se opto deliberadamente por modificar ambas cadenas o buffer's y convertirlas ambas a min\u00fasculas, la comparaci\u00f3n lo realiza a trav\u00e9s del valor ascii de cada car\u00e1cter. Par\u00e1metros Par\u00e1metro Descripci\u00f3n string primera cadena o buffer a comparar string2 segunda cadena o buffer a comparar Retorno Si las cadenas son iguales ZF ( zero flag ) = 1 Si las cadenas No son iguales ZF ( zero flag ) = 0 Copiar el contenido de una buffer a otro buffer Algo de teor\u00eda Anteriormente se menciono de las instrucciones para manipular de forma f\u00e1cil bloques de de memoria, es decir arrays. MOVES (MOVSB, MOVSW, MOVSD) Para esta macro se volvi\u00f3 a usar una de esas intrucciones el cual nos ayuda a copiar data o informaci\u00f3n que esta indexada por el registro SI (8 y 16 bits) o ESI (32 bits), hacia la posici\u00f3n que esta indexada por el registro DI (8 y 16 bits) o EDI (32 bits). INSTRUCCI\u00d3N DESCRIPCI\u00d3N MOVSB mover (copiar) bytes MOVSW mover (copiar) words MOVSD mover (copiar) double words Ambos registros, SI o ESI y DI o EDI , se incrementan o disminuye de forma autom\u00e1tica, dependiendo del la bandera direcci\u00f3n INSTRUCCION SIGNIFICADO VALOR DE LA BANDERA DIRRECCION EFECTO SOBRE SI/ESI y DI/EDI DIRRECCION CLD clear direction flag clear (0) Incrementar hacia adelante STD set direction flag set (1) Decrementar hacia atr\u00e1s Nuevamente aparece el nem\u00f3nico REP , anteriormente explicado, pero recordenemo que lo podemos usar de las siguientes maneras INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 (8 y 16 bits) repetir mientras ECX > 0 (32 bits) REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis) Macro copyData MACRO arrayDestination , array_source LOCAL COPY COPY: CLD LEA si , array_source LEA di , arrayDestination MOV cx , LENGTHOF arrayDestination - 1 REP MOVSB ENDM Prop\u00f3sito copyData: macro para copiar una cantidad de caracteres iniciando desde la posici\u00f3n 0 de un buffer de partida a un buffer destino. Esto lo hace copiando el byte de una direcci\u00f3n de memoria indexada por el registro SI haca otra direcci\u00f3n de memoria indexada por el registro DI Par\u00e1metros Par\u00e1metro Descripci\u00f3n array_destination buffer de destino, donde se copiaran los caracteres array_source buffer de partida, del cual se copiaran los caracteres quantity cantidad de caracteres a copiar Retorno nada Limpiar el contenido de un buffer Algo de teor\u00eda Para esta macro nuevamente se volvi\u00f3 a usar una de esas intrucciones que nos permite manipular arrays. SOTORAGE (STOSB, STOSW, STOSD) Esta instruci\u00f3n nos permite almacenar el contenido de AL/AX/EAX , respectivamente a un espacio de memoria direccionada o indexada por el registro DI (para 8 y 16 bits) o el el registro EDI (para 32 bits) INSTRUCCI\u00d3N DESCRIPCI\u00d3N STOSB guardar bytes STOSW guardar words STOSD guardar double words Ya se el registro DI o EDI , se incrementan o disminuye de forma autom\u00e1tica, dependiendo del la bandera direcci\u00f3n INSTRUCCION SIGNIFICADO VALOR DE LA BANDERA DIRRECCION EFECTO SOBRE SI/ESI y DI/EDI DIRRECCION CLD clear direction flag clear (0) Incrementar hacia adelante STD set direction flag set (1) Decrementar hacia atr\u00e1s Nuevamente aparece el nem\u00f3nico REP , anteriormente explicado, pero recordemos que lo podemos usar de las siguientes maneras INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 (8 y 16 bits) repetir mientras ECX > 0 (32 bits) REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis) Macro limpiarBuffer MACRO buffer MOV al , 24h LEA di , buffer MOV cx , LENGTHOF buffer CLD REP stosb ENDM Prop\u00f3sito limpiarBuffer: macro para limpiar el contenido de un buffer iniciando desde la posici\u00f3n 0, lo que hace es colocar el car\u00e1cter de fin de cadena ( $ ) en todas las pociones del buffer Par\u00e1metros Par\u00e1metro Descripci\u00f3n buffer buffer a limpiar Retorno nada","title":"Prop\u00f3sito General"},{"location":"macros/macros/#macros-de-proposito-general","text":"","title":"MACROS DE PROP\u00d3SITO GENERAL"},{"location":"macros/macros/#descripcion","text":"En este apartado se encuentran varios macros de prop\u00f3sito general que son utilizada para completar la l\u00f3gica del ejemplo, poder interactuar con el usuario y macros usados durante durante el an\u00e1lisis. Algunas de las macros descrita en este apartado fueron implementados usando la interrupci\u00f3n (INT) 21h","title":"Descripci\u00f3n"},{"location":"macros/macros/#importante","text":"En varias de siguientes macros se usaran instrucciones primitivas que nos permite manejar o procesar de forma f\u00e1cil grandes bloques de datos, por lo cual es de suma importancia el uso del segmento EXTRA DATA (es) , si revisamos el main al incio de la proc main hay una l\u00ednea de c\u00f3digo en la cual hacemos uso del segmento extra data. main PROC MOV dx , @ data MOV ds , dx ;; uso del segmento de datos (DS) MOV es , dx ;; uso del segmento extra dato (es) ;; ... ;; ... ;; .. m\u00e1s c\u00f3digo main ENDP","title":"IMPORTANTE"},{"location":"macros/macros/#visualizacion-de-un-caracter-en-pantalla","text":"","title":"Visualizaci\u00f3n de un car\u00e1cter en pantalla"},{"location":"macros/macros/#macro","text":"imprimirC MACRO ch aracter MOV ah , 02h MOV dl , ch aracter INT 21h ENDM","title":"Macro"},{"location":"macros/macros/#proposito","text":"imprimirC: macro para imprimir o visualizar una car\u00e1cter en pantalla, el car\u00e1cter debe de estar en su valor ascii.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros","text":"Par\u00e1metro Descripci\u00f3n character car\u00e1cter a visualizar en pantalla","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno","text":"nada","title":"Retorno"},{"location":"macros/macros/#visualizacion-de-una-cadena-de-caracteres-en-pantalla","text":"","title":"Visualizaci\u00f3n de una cadena de caracteres en pantalla"},{"location":"macros/macros/#macro_1","text":"imprimir MACRO string MOV ah , 09h MOV dx , offset string INT 21h ENDM","title":"Macro"},{"location":"macros/macros/#proposito_1","text":"imprimir: macro para imprimir o visualizar una cadena de caracteres en pantalla, los caracteres deben estar en su valor ascii.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_1","text":"Par\u00e1metro Descripci\u00f3n string buffer que contiene el conjunto de caracteres a visualizar en pantalla","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_1","text":"nada","title":"Retorno"},{"location":"macros/macros/#entrada-o-lectura-de-caracter","text":"","title":"Entrada o lectura de car\u00e1cter"},{"location":"macros/macros/#macro_2","text":"leerCaracter MACRO MOV ah , 01h ;; con ECHO ; MOV ah, 08h ;; sin ECHO INT 21h ENDM","title":"Macro"},{"location":"macros/macros/#proposito_2","text":"leerCaracter: macro para leer un car\u00e1cter del dispositivo de entrada, este puede tener dos variantes. Con Echo: Mov ah, 01h , el car\u00e1cter de entrada se muestra en pantalla o el dispositivo de salida. Sin Echo: Mov ah, 08h , el car\u00e1cter de entrada no se muestra en pantalla o el dispositivo de salida.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_2","text":"","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_2","text":"AL = 'c\u00f3digo ascii del car\u00e1cter le\u00eddo'","title":"Retorno"},{"location":"macros/macros/#entrada-o-lectura-de-una-cadena-de-caracteres","text":"","title":"Entrada o lectura de una cadena de caracteres"},{"location":"macros/macros/#macro_3","text":"leerCadena MACRO buffer LOCAL LEER , FIN XOR si , si LEER: leerCaracter CMP al , 13 ; 0ah->\\n (LINE FEED) 0dh-> retorno de carro JE FIN MOV buffer [ si ], al INC si JMP LEER FIN: MOV buffer [ si ], 00h ENDM","title":"Macro"},{"location":"macros/macros/#proposito_3","text":"leerCadena: macro para leer una cadena de caracteres del dispositivo de entrada.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_3","text":"Par\u00e1metro Descripci\u00f3n buffer buffer el cual servir\u00e1 para almacenar la cadena de caracteres le\u00eddos.","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_3","text":"nada","title":"Retorno"},{"location":"macros/macros/#limpiar-pantalla-o-consola","text":"","title":"Limpiar pantalla o consola"},{"location":"macros/macros/#macro_4","text":"limpiarConsola MACRO MOV AX , 0600H ;Llamada a la funci\u00f3n MOV BH , 07H ;color de fondo y color de letra MOV CX , 0000H ;coordenadas de inicio MOV DX , 184FH ;coordenadas de fin INT 10H ENDM limpiarConsola MACRO LOCAL CL EAR MOV cx , 15 CLEAR: printChar 0Ah LOOP CL EAR ENDM","title":"Macro"},{"location":"macros/macros/#proposito_4","text":"clearConsole: macro para limpiar la consola, para este hay dos soluciones: La primera es usando la interrupci\u00f3n 10h. La segunda es hacer un LOOP imprimiendo saltos de linea.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_4","text":"","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_4","text":"nada","title":"Retorno"},{"location":"macros/macros/#convertir-una-cadena-de-texto-a-minusculas","text":"","title":"Convertir una cadena de texto a min\u00fasculas"},{"location":"macros/macros/#nota","text":"Ya que estamos trabajando con los valores ascii de los caracteres es muy sencillo convertir las letras en may\u00fasculas o min\u00fasculas, basta con observar una tabla de los valores ascii, tomemos por ejemplo las siguientes letras Valor Ascii (decimal) Letra May\u00fascula Valor Ascii (decimal) Letra Min\u00fascula 65 A 97 a 66 B 98 b 67 C 99 c . . . . . . . . . . . . 88 X 120 x 89 Y 121 y 90 Z 122 z En conclusi\u00f3n: El rango de las letras may\u00fasculas esta entre [65, 90]. El rango de las letras min\u00fasculas esta entre [97, 122] Para pasar de May\u00fascula a Min\u00fascula basta con sumar 32(d) al valor ascii del car\u00e1cter. Para pasar de Min\u00fascula a May\u00fascula basta con restar 32(d) al valor ascii del car\u00e1cter.","title":"Nota"},{"location":"macros/macros/#macro_5","text":"toLowerCase MACRO string LOCAL ITERATE , NEXT , END_TO_LOWERCASE XOR si , si MOV cx , LENGTHOF string ITERATE: CMP string [ si ], 36 JE END_TO_LOWERCASE ;; jump if string[si] == '$' CMP string [ si ], 65 JB NEXT ;; jump if string[si] < 65d CMP string [ si ], 90 JA NEXT ;; jump if string[si] > 90d ADD string [ si ], 32 INC si LOOP ITERATE JMP END_TO_LOWERCASE NEXT: INC si JMP ITERATE END_TO_LOWERCASE: ENDM","title":"Macro"},{"location":"macros/macros/#proposito_5","text":"toLowerCase: macro que convierte una cadena de letras a min\u00fasculas, modificando la misma cadena o buffer que es pasado.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_5","text":"Par\u00e1metro Descripci\u00f3n string cadena de texto o buffer para convertir a min\u00fasculas","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_5","text":"nada","title":"Retorno"},{"location":"macros/macros/#comparar-dos-cadenas-de-caracteres-o-buffers","text":"","title":"Comparar dos cadenas de caracteres o buffer's"},{"location":"macros/macros/#algo-de-teoria","text":"Para poder manipular bloques de datos hay instrucciones primitivas que nos permite manejar o procesar de forma f\u00e1cil arrays de bytes , words y double words .","title":"Algo de teor\u00eda"},{"location":"macros/macros/#compare-cmpsb-cmpsw-cmpsd","text":"Esta instrucci\u00f3n primitiva nos ayuda a comparar el contenido de de dos posiciones de memoria direccionadas o indexadas por los registros SI (8 y 16 bits) o ESI (32 bits) y DI (8 y 16 bits) o EDI (32 bits). INSTRUCCI\u00d3N DESCRIPCI\u00d3N CMPSB comparar bytes CMPSW comparar words CMPSD comparar double words Ambos registros, SI o ESI y DI o EDI , se incrementan de forma autom\u00e1tica. En esta macro aparece el nen\u00f3mico REP de repetici\u00f3n. El prefijo de repetici\u00f3n le permite procesar un array completa usando una sola instrucci\u00f3n. Se pueden utilizar los siguientes prefijos de repetici\u00f3n: INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 repetir mientras ECX > 0 REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis)","title":"COMPARE (CMPSB, CMPSW, CMPSD)"},{"location":"macros/macros/#macro_6","text":"compararCadenas MACRO string , string2 LEA si , string LEA di , string2 MOV cx , LENGTHOF string REPE CMPSB ENDM","title":"Macro"},{"location":"macros/macros/#proposito_6","text":"compareString: comparar el contenido entre dos cadenas o buffer's, la comparaci\u00f3n lo realiza a trav\u00e9s del valor ascii de cada car\u00e1cter, tener en cuenta que la comparaci\u00f3n es debe ser de dos arrays de tipo byte.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_6","text":"Par\u00e1metro Descripci\u00f3n string primera cadena o buffer a comparar string2 segunda cadena o buffer a comparar","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_6","text":"Si las cadenas son iguales ZF ( zero flag ) = 1 Si las cadenas No son iguales ZF ( zero flag ) = 0","title":"Retorno"},{"location":"macros/macros/#comparar-dos-cadenas-de-caracteres-o-buffers-case-insensitive","text":"","title":"Comparar dos cadenas de caracteres o buffer's case-insensitive"},{"location":"macros/macros/#macro_7","text":"compararIngorandoCase MACRO string , string2 toLowerCase string toLowerCase string2 compareString string , string2 ENDM","title":"Macro"},{"location":"macros/macros/#proposito_7","text":"compararIngorandoCase: comparar el contenido entre dos cadenas o buffer's de forma case-insensitive, para lograrlo se opto deliberadamente por modificar ambas cadenas o buffer's y convertirlas ambas a min\u00fasculas, la comparaci\u00f3n lo realiza a trav\u00e9s del valor ascii de cada car\u00e1cter.","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_7","text":"Par\u00e1metro Descripci\u00f3n string primera cadena o buffer a comparar string2 segunda cadena o buffer a comparar","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_7","text":"Si las cadenas son iguales ZF ( zero flag ) = 1 Si las cadenas No son iguales ZF ( zero flag ) = 0","title":"Retorno"},{"location":"macros/macros/#copiar-el-contenido-de-una-buffer-a-otro-buffer","text":"","title":"Copiar el contenido de una buffer a otro buffer"},{"location":"macros/macros/#algo-de-teoria_1","text":"Anteriormente se menciono de las instrucciones para manipular de forma f\u00e1cil bloques de de memoria, es decir arrays.","title":"Algo de teor\u00eda"},{"location":"macros/macros/#moves-movsb-movsw-movsd","text":"Para esta macro se volvi\u00f3 a usar una de esas intrucciones el cual nos ayuda a copiar data o informaci\u00f3n que esta indexada por el registro SI (8 y 16 bits) o ESI (32 bits), hacia la posici\u00f3n que esta indexada por el registro DI (8 y 16 bits) o EDI (32 bits). INSTRUCCI\u00d3N DESCRIPCI\u00d3N MOVSB mover (copiar) bytes MOVSW mover (copiar) words MOVSD mover (copiar) double words Ambos registros, SI o ESI y DI o EDI , se incrementan o disminuye de forma autom\u00e1tica, dependiendo del la bandera direcci\u00f3n INSTRUCCION SIGNIFICADO VALOR DE LA BANDERA DIRRECCION EFECTO SOBRE SI/ESI y DI/EDI DIRRECCION CLD clear direction flag clear (0) Incrementar hacia adelante STD set direction flag set (1) Decrementar hacia atr\u00e1s Nuevamente aparece el nem\u00f3nico REP , anteriormente explicado, pero recordenemo que lo podemos usar de las siguientes maneras INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 (8 y 16 bits) repetir mientras ECX > 0 (32 bits) REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis)","title":"MOVES (MOVSB, MOVSW, MOVSD)"},{"location":"macros/macros/#macro_8","text":"copyData MACRO arrayDestination , array_source LOCAL COPY COPY: CLD LEA si , array_source LEA di , arrayDestination MOV cx , LENGTHOF arrayDestination - 1 REP MOVSB ENDM","title":"Macro"},{"location":"macros/macros/#proposito_8","text":"copyData: macro para copiar una cantidad de caracteres iniciando desde la posici\u00f3n 0 de un buffer de partida a un buffer destino. Esto lo hace copiando el byte de una direcci\u00f3n de memoria indexada por el registro SI haca otra direcci\u00f3n de memoria indexada por el registro DI","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_8","text":"Par\u00e1metro Descripci\u00f3n array_destination buffer de destino, donde se copiaran los caracteres array_source buffer de partida, del cual se copiaran los caracteres quantity cantidad de caracteres a copiar","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_8","text":"nada","title":"Retorno"},{"location":"macros/macros/#limpiar-el-contenido-de-un-buffer","text":"","title":"Limpiar el contenido de un buffer"},{"location":"macros/macros/#algo-de-teoria_2","text":"Para esta macro nuevamente se volvi\u00f3 a usar una de esas intrucciones que nos permite manipular arrays.","title":"Algo de teor\u00eda"},{"location":"macros/macros/#sotorage-stosb-stosw-stosd","text":"Esta instruci\u00f3n nos permite almacenar el contenido de AL/AX/EAX , respectivamente a un espacio de memoria direccionada o indexada por el registro DI (para 8 y 16 bits) o el el registro EDI (para 32 bits) INSTRUCCI\u00d3N DESCRIPCI\u00d3N STOSB guardar bytes STOSW guardar words STOSD guardar double words Ya se el registro DI o EDI , se incrementan o disminuye de forma autom\u00e1tica, dependiendo del la bandera direcci\u00f3n INSTRUCCION SIGNIFICADO VALOR DE LA BANDERA DIRRECCION EFECTO SOBRE SI/ESI y DI/EDI DIRRECCION CLD clear direction flag clear (0) Incrementar hacia adelante STD set direction flag set (1) Decrementar hacia atr\u00e1s Nuevamente aparece el nem\u00f3nico REP , anteriormente explicado, pero recordemos que lo podemos usar de las siguientes maneras INSTRUCCI\u00d3N DESCRIPCI\u00d3N REP repetir mientras CX > 0 (8 y 16 bits) repetir mientras ECX > 0 (32 bits) REPE, REPZ repetir mientras la bandera Z = 1 Y CX > 0 (8 y 16 bits) repetir mientras la bandera Z = 1 Y ECX > 0 (32 bits) REPNE, REPNZ repetir mientras la bandera Z = 0 Y CX > 0 (8 y 16 btis) repetir mientras la bandera Z = 0 Y ECX > 0 (32 btis)","title":"SOTORAGE (STOSB, STOSW, STOSD)"},{"location":"macros/macros/#macro_9","text":"limpiarBuffer MACRO buffer MOV al , 24h LEA di , buffer MOV cx , LENGTHOF buffer CLD REP stosb ENDM","title":"Macro"},{"location":"macros/macros/#proposito_9","text":"limpiarBuffer: macro para limpiar el contenido de un buffer iniciando desde la posici\u00f3n 0, lo que hace es colocar el car\u00e1cter de fin de cadena ( $ ) en todas las pociones del buffer","title":"Prop\u00f3sito"},{"location":"macros/macros/#parametros_9","text":"Par\u00e1metro Descripci\u00f3n buffer buffer a limpiar","title":"Par\u00e1metros"},{"location":"macros/macros/#retorno_9","text":"nada","title":"Retorno"}]}